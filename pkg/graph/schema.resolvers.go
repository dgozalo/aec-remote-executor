package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"fmt"
	"github.com/dgozalo/aec-remote-executor/pkg/graph/model"
	"github.com/pkg/errors"
)

// RunExecution is the resolver for the runExecution field.
func (r *mutationResolver) RunExecution(ctx context.Context, input model.NewExecution) (*model.Execution, error) {
	temporalExec := r.TemporalCompiler.RunCompileWorker(input)

	execution, err := r.ExecutionService.CreateExecution(input, temporalExec)
	if err != nil {
		return nil, err
		errors.Wrap(err, "there was a problem creating an execution")
	}

	return &model.Execution{
		ID:       fmt.Sprint(execution.ID),
		Language: execution.Language,
		Code:     execution.Code,
	}, nil
}

// GetExecutions is the resolver for the GetExecutions field.
func (r *queryResolver) GetExecutions(ctx context.Context) ([]*model.Execution, error) {
	dbExecs, err := r.ExecutionService.GetExecutions()
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem getting executions froem the database")
	}
	var executions []*model.Execution
	for _, execution := range dbExecs {
		executions = append(executions, &model.Execution{
			ID:       fmt.Sprint(execution.ID),
			Language: execution.Language,
			Code:     execution.Code,
		})
	}
	return executions, nil
}

// GetExecution is the resolver for the GetExecution field.
func (r *queryResolver) GetExecution(ctx context.Context, id string) (*model.Execution, error) {
	execution, err := r.ExecutionService.GetExecution(id)
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem obtaining a single execution from the database")
	}
	return &model.Execution{
		ID:       id,
		Language: execution.Language,
		Code:     execution.Code,
	}, nil
}

// GetExecutionStatus is the resolver for the GetExecutionStatus field.
func (r *queryResolver) GetExecutionStatus(ctx context.Context, id string) (*model.ExecutionResult, error) {
	exec, err := r.ExecutionService.GetExecution(id)
	if err != nil {
		return nil, errors.Wrap(err, "could not retrieve an execution from the database")
	}

	result, err := r.TemporalCompiler.GetCompilationStatus(exec)
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem obtaining the Temporal execution result")
	}
	return result, nil
}

// GetAlumni is the resolver for the GetAlumni field.
func (r *queryResolver) GetAlumni(ctx context.Context) ([]*model.Alumni, error) {
	alumnus, err := r.ManagementService.GetAlumnus()
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem getting alumni from the database")
	}
	var alumni []*model.Alumni
	for _, alumnus := range alumnus {
		alum := &model.Alumni{
			ID:        fmt.Sprint(alumnus.ID),
			FirstName: alumnus.FirstName,
			LastName:  alumnus.LastName,
			Email:     alumnus.Email,
		}
		alum.Subjects = make([]*model.Subject, 0)
		for _, s := range alumnus.Subjects {
			alum.Subjects = append(alum.Subjects, &model.Subject{
				ID:       fmt.Sprint(s.ID),
				Name:     s.SubjectName,
				Semester: int(s.Semester),
			})
		}
		alumni = append(alumni, alum)
	}
	return alumni, nil
}

// GetAlumnus is the resolver for the GetAlumnus field.
func (r *queryResolver) GetAlumnus(ctx context.Context, id string) (*model.Alumni, error) {
	alum, err := r.ManagementService.GetAlum(id)
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem getting an alumnus from the database")
	}
	var subjects []*model.Subject
	alumnus := &model.Alumni{
		ID:             fmt.Sprint(alum.ID),
		FirstName:      alum.FirstName,
		LastName:       alum.LastName,
		Email:          alum.Email,
		GraduationYear: string(alum.GraduationYear),
	}
	for _, s := range alum.Subjects {
		gqlSubject := &model.Subject{
			ID:       fmt.Sprint(s.ID),
			Name:     s.SubjectName,
			Semester: int(s.Semester),
		}
		for _, a := range s.Assignments {
			gqlAssignment := &model.Assignment{
				ID:          fmt.Sprint(a.ID),
				Title:       a.AssignmentTitle,
				Description: a.AssignmentDescription,
			}
			for _, e := range a.Examples {
				gqlExample := &model.AssignmentExample{
					ID:          fmt.Sprint(e.ID),
					Title:       e.ExampleTitle,
					Description: e.ExampleDescription,
				}
				gqlAssignment.AssignmentExamples = append(gqlAssignment.AssignmentExamples, gqlExample)
			}
			for _, t := range a.CodeTemplates {
				gqlTemplate := &model.AssignmentCodeTemplate{
					ID:       fmt.Sprint(t.ID),
					Language: t.Language,
					Code:     t.Code,
				}
				gqlAssignment.AssignmentCodeTemplates = append(gqlAssignment.AssignmentCodeTemplates, gqlTemplate)
			}
			gqlSubject.Assignments = append(gqlSubject.Assignments, gqlAssignment)
		}
		subjects = append(subjects, gqlSubject)
	}
	alumnus.Subjects = subjects
	return alumnus, nil
}

// GetProfessors is the resolver for the GetProfessors field.
func (r *queryResolver) GetProfessors(ctx context.Context) ([]*model.Professor, error) {
	professors, err := r.ManagementService.GetProfessors()
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem getting professors from the database")
	}
	var profs []*model.Professor
	for _, professor := range professors {
		pr := &model.Professor{
			ID:        fmt.Sprint(professor.ID),
			FirstName: professor.FirstName,
			LastName:  professor.LastName,
			Email:     professor.Email,
		}
		for _, s := range professor.Subjects {
			pr.Subjects = append(pr.Subjects, &model.Subject{
				ID:       fmt.Sprint(s.ID),
				Name:     s.SubjectName,
				Semester: int(s.Semester),
			})
		}
		profs = append(profs, pr)
	}
	return profs, nil
}

// GetProfessor is the resolver for the GetProfessor field.
func (r *queryResolver) GetProfessor(ctx context.Context, id string) (*model.Professor, error) {
	pr, err := r.ManagementService.GetProfessor(id)
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem getting a professor from the database")
	}
	professor := &model.Professor{
		ID:        fmt.Sprint(pr.ID),
		FirstName: pr.FirstName,
		LastName:  pr.LastName,
		Email:     pr.Email,
	}
	for _, s := range pr.Subjects {
		professor.Subjects = append(professor.Subjects, &model.Subject{
			ID:       fmt.Sprint(s.ID),
			Name:     s.SubjectName,
			Semester: int(s.Semester),
		})
	}
	return professor, nil
}

// GetSubjects is the resolver for the GetSubjects field.
func (r *queryResolver) GetSubjects(ctx context.Context) ([]*model.Subject, error) {
	subjects, err := r.ManagementService.GetSubjects()
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem getting subjects from the database")
	}
	var subs []*model.Subject
	for _, subject := range subjects {
		s := &model.Subject{
			ID:       fmt.Sprint(subject.ID),
			Name:     subject.SubjectName,
			Semester: int(subject.Semester),
		}
		for _, a := range subject.Assignments {
			s.Assignments = append(s.Assignments, &model.Assignment{
				ID:          fmt.Sprint(a.ID),
				Title:       a.AssignmentTitle,
				Description: a.AssignmentDescription,
			})
		}
		subs = append(subs, s)
	}
	return subs, nil
}

// GetSubject is the resolver for the GetSubject field.
func (r *queryResolver) GetSubject(ctx context.Context, id string) (*model.Subject, error) {
	panic(fmt.Errorf("not implemented: GetSubject - GetSubject"))
}

// GetAssignments is the resolver for the GetAssignments field.
func (r *queryResolver) GetAssignments(ctx context.Context) ([]*model.Assignment, error) {
	panic(fmt.Errorf("not implemented: GetAssignments - GetAssignments"))
}

// GetAssignment is the resolver for the GetAssignment field.
func (r *queryResolver) GetAssignment(ctx context.Context, id string) (*model.Assignment, error) {
	panic(fmt.Errorf("not implemented: GetAssignment - GetAssignment"))
}

// ExecutionStatus is the resolver for the ExecutionStatus field.
func (r *subscriptionResolver) ExecutionStatus(ctx context.Context, id string) (<-chan *model.ExecutionResult, error) {
	panic(fmt.Errorf("not implemented: ExecutionStatus - ExecutionStatus"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
