package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"github.com/pkg/errors"

	"github.com/dgozalo/aec-remote-executor/pkg/graph/model"
	models "github.com/dgozalo/aec-remote-executor/pkg/model"
)

// RunExecution is the resolver for the runExecution field.
func (r *mutationResolver) RunExecution(ctx context.Context, input model.NewExecution) (*model.Execution, error) {
	temporalExec := r.TemporalCompiler.RunCompileWorker(input)

	internalExec := models.InternalExecution{
		Language:   input.Language,
		Code:       input.Code,
		WorkflowID: temporalExec.WorkflowID,
		RunID:      temporalExec.RunID,
	}

	exec, err := r.ExecutionStore.CreateExecution(&internalExec)
	if err != nil {
		return nil, errors.Wrap(err, "could not store the execution in the database")
	}

	return exec, nil
}

// GetExecutions is the resolver for the GetExecutions field.
func (r *queryResolver) GetExecutions(ctx context.Context) ([]*model.Execution, error) {
	execs, err := r.ExecutionStore.GetAll()
	if err != nil {
		return nil, errors.Wrap(err, "could not retrieve all the executions from the database")
	}
	return execs, nil
}

// GetExecution is the resolver for the GetExecution field.
func (r *queryResolver) GetExecution(ctx context.Context, id string) (*model.Execution, error) {
	exec, err := r.ExecutionStore.GetOne(id)
	if err != nil {
		return nil, errors.Wrap(err, "could not retrieve an execution from the database")
	}
	return &model.Execution{
		ID:       id,
		Language: exec.Language,
		Code:     exec.Code,
	}, nil
}

// GetExecutionStatus is the resolver for the GetExecutionStatus field.
func (r *queryResolver) GetExecutionStatus(ctx context.Context, id string) (*model.ExecutionResult, error) {
	exec, err := r.ExecutionStore.GetOne(id)
	if err != nil {
		return nil, errors.Wrap(err, "could not retrieve an execution from the database")
	}

	result, err := r.TemporalCompiler.GetCompilationStatus(exec)
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem obtaining the Temporal execution result")
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
