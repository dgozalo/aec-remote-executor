package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"fmt"
	"github.com/dgozalo/aec-remote-executor/pkg/graph/model"
	"github.com/pkg/errors"
)

// RunExecution is the resolver for the runExecution field.
func (r *mutationResolver) RunExecution(ctx context.Context, input model.NewExecution) (*model.Execution, error) {
	temporalExec := r.TemporalCompiler.RunCompileWorker(input)

	execution, err := r.ExecutionService.CreateExecution(input, temporalExec)
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem creating an execution")
	}

	return &model.Execution{
		ID:       fmt.Sprint(execution.ExecutionID),
		Language: execution.Language,
		Code:     execution.Code,
	}, nil
}

// GetExecutions is the resolver for the GetExecutions field.
func (r *queryResolver) GetExecutions(ctx context.Context) ([]*model.Execution, error) {
	dbExecs, err := r.ExecutionService.GetExecutions()
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem getting executions froem the database")
	}
	var executions []*model.Execution
	for _, execution := range dbExecs {
		executions = append(executions, &model.Execution{
			ID:       fmt.Sprint(execution.ExecutionID),
			Language: execution.Language,
			Code:     execution.Code,
		})
	}
	return executions, nil
}

// GetExecution is the resolver for the GetExecution field.
func (r *queryResolver) GetExecution(ctx context.Context, id string) (*model.Execution, error) {
	execution, err := r.ExecutionService.GetExecution(id)
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem obtaining a single execution from the database")
	}
	return &model.Execution{
		ID:       id,
		Language: execution.Language,
		Code:     execution.Code,
	}, nil
}

// GetExecutionStatus is the resolver for the GetExecutionStatus field.
func (r *queryResolver) GetExecutionStatus(ctx context.Context, id string) (*model.ExecutionResult, error) {
	exec, err := r.ExecutionService.GetExecution(id)
	if err != nil {
		return nil, errors.Wrap(err, "could not retrieve an execution from the database")
	}

	result, err := r.TemporalCompiler.GetCompilationStatus(exec)
	if err != nil {
		return nil, errors.Wrap(err, "there was a problem obtaining the Temporal execution result")
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
